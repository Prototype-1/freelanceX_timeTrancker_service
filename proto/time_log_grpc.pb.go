// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.1
// source: proto/time_log.proto

package time_logpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TimeLogService_CreateTimeLog_FullMethodName        = "/freelanceX.time_tracker.TimeLogService/CreateTimeLog"
	TimeLogService_GetTimeLogsByUser_FullMethodName    = "/freelanceX.time_tracker.TimeLogService/GetTimeLogsByUser"
	TimeLogService_GetTimeLogsByProject_FullMethodName = "/freelanceX.time_tracker.TimeLogService/GetTimeLogsByProject"
	TimeLogService_UpdateTimeLog_FullMethodName        = "/freelanceX.time_tracker.TimeLogService/UpdateTimeLog"
	TimeLogService_DeleteTimeLog_FullMethodName        = "/freelanceX.time_tracker.TimeLogService/DeleteTimeLog"
)

// TimeLogServiceClient is the client API for TimeLogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// === Service ===
type TimeLogServiceClient interface {
	CreateTimeLog(ctx context.Context, in *CreateTimeLogRequest, opts ...grpc.CallOption) (*CreateTimeLogResponse, error)
	GetTimeLogsByUser(ctx context.Context, in *GetTimeLogsByUserRequest, opts ...grpc.CallOption) (*TimeLogsResponse, error)
	GetTimeLogsByProject(ctx context.Context, in *GetTimeLogsByProjectRequest, opts ...grpc.CallOption) (*TimeLogsResponse, error)
	UpdateTimeLog(ctx context.Context, in *UpdateTimeLogRequest, opts ...grpc.CallOption) (*UpdateTimeLogResponse, error)
	DeleteTimeLog(ctx context.Context, in *DeleteTimeLogRequest, opts ...grpc.CallOption) (*DeleteTimeLogResponse, error)
}

type timeLogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTimeLogServiceClient(cc grpc.ClientConnInterface) TimeLogServiceClient {
	return &timeLogServiceClient{cc}
}

func (c *timeLogServiceClient) CreateTimeLog(ctx context.Context, in *CreateTimeLogRequest, opts ...grpc.CallOption) (*CreateTimeLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTimeLogResponse)
	err := c.cc.Invoke(ctx, TimeLogService_CreateTimeLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeLogServiceClient) GetTimeLogsByUser(ctx context.Context, in *GetTimeLogsByUserRequest, opts ...grpc.CallOption) (*TimeLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimeLogsResponse)
	err := c.cc.Invoke(ctx, TimeLogService_GetTimeLogsByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeLogServiceClient) GetTimeLogsByProject(ctx context.Context, in *GetTimeLogsByProjectRequest, opts ...grpc.CallOption) (*TimeLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimeLogsResponse)
	err := c.cc.Invoke(ctx, TimeLogService_GetTimeLogsByProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeLogServiceClient) UpdateTimeLog(ctx context.Context, in *UpdateTimeLogRequest, opts ...grpc.CallOption) (*UpdateTimeLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTimeLogResponse)
	err := c.cc.Invoke(ctx, TimeLogService_UpdateTimeLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeLogServiceClient) DeleteTimeLog(ctx context.Context, in *DeleteTimeLogRequest, opts ...grpc.CallOption) (*DeleteTimeLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTimeLogResponse)
	err := c.cc.Invoke(ctx, TimeLogService_DeleteTimeLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimeLogServiceServer is the server API for TimeLogService service.
// All implementations must embed UnimplementedTimeLogServiceServer
// for forward compatibility.
//
// === Service ===
type TimeLogServiceServer interface {
	CreateTimeLog(context.Context, *CreateTimeLogRequest) (*CreateTimeLogResponse, error)
	GetTimeLogsByUser(context.Context, *GetTimeLogsByUserRequest) (*TimeLogsResponse, error)
	GetTimeLogsByProject(context.Context, *GetTimeLogsByProjectRequest) (*TimeLogsResponse, error)
	UpdateTimeLog(context.Context, *UpdateTimeLogRequest) (*UpdateTimeLogResponse, error)
	DeleteTimeLog(context.Context, *DeleteTimeLogRequest) (*DeleteTimeLogResponse, error)
	mustEmbedUnimplementedTimeLogServiceServer()
}

// UnimplementedTimeLogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTimeLogServiceServer struct{}

func (UnimplementedTimeLogServiceServer) CreateTimeLog(context.Context, *CreateTimeLogRequest) (*CreateTimeLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTimeLog not implemented")
}
func (UnimplementedTimeLogServiceServer) GetTimeLogsByUser(context.Context, *GetTimeLogsByUserRequest) (*TimeLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimeLogsByUser not implemented")
}
func (UnimplementedTimeLogServiceServer) GetTimeLogsByProject(context.Context, *GetTimeLogsByProjectRequest) (*TimeLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimeLogsByProject not implemented")
}
func (UnimplementedTimeLogServiceServer) UpdateTimeLog(context.Context, *UpdateTimeLogRequest) (*UpdateTimeLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTimeLog not implemented")
}
func (UnimplementedTimeLogServiceServer) DeleteTimeLog(context.Context, *DeleteTimeLogRequest) (*DeleteTimeLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTimeLog not implemented")
}
func (UnimplementedTimeLogServiceServer) mustEmbedUnimplementedTimeLogServiceServer() {}
func (UnimplementedTimeLogServiceServer) testEmbeddedByValue()                        {}

// UnsafeTimeLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimeLogServiceServer will
// result in compilation errors.
type UnsafeTimeLogServiceServer interface {
	mustEmbedUnimplementedTimeLogServiceServer()
}

func RegisterTimeLogServiceServer(s grpc.ServiceRegistrar, srv TimeLogServiceServer) {
	// If the following call pancis, it indicates UnimplementedTimeLogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TimeLogService_ServiceDesc, srv)
}

func _TimeLogService_CreateTimeLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTimeLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeLogServiceServer).CreateTimeLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeLogService_CreateTimeLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeLogServiceServer).CreateTimeLog(ctx, req.(*CreateTimeLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeLogService_GetTimeLogsByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimeLogsByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeLogServiceServer).GetTimeLogsByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeLogService_GetTimeLogsByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeLogServiceServer).GetTimeLogsByUser(ctx, req.(*GetTimeLogsByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeLogService_GetTimeLogsByProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimeLogsByProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeLogServiceServer).GetTimeLogsByProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeLogService_GetTimeLogsByProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeLogServiceServer).GetTimeLogsByProject(ctx, req.(*GetTimeLogsByProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeLogService_UpdateTimeLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTimeLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeLogServiceServer).UpdateTimeLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeLogService_UpdateTimeLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeLogServiceServer).UpdateTimeLog(ctx, req.(*UpdateTimeLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeLogService_DeleteTimeLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTimeLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeLogServiceServer).DeleteTimeLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeLogService_DeleteTimeLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeLogServiceServer).DeleteTimeLog(ctx, req.(*DeleteTimeLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TimeLogService_ServiceDesc is the grpc.ServiceDesc for TimeLogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimeLogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "freelanceX.time_tracker.TimeLogService",
	HandlerType: (*TimeLogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTimeLog",
			Handler:    _TimeLogService_CreateTimeLog_Handler,
		},
		{
			MethodName: "GetTimeLogsByUser",
			Handler:    _TimeLogService_GetTimeLogsByUser_Handler,
		},
		{
			MethodName: "GetTimeLogsByProject",
			Handler:    _TimeLogService_GetTimeLogsByProject_Handler,
		},
		{
			MethodName: "UpdateTimeLog",
			Handler:    _TimeLogService_UpdateTimeLog_Handler,
		},
		{
			MethodName: "DeleteTimeLog",
			Handler:    _TimeLogService_DeleteTimeLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/time_log.proto",
}
